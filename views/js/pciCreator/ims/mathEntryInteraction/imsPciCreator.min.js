

define('tpl!mathEntryInteraction/creator/tpl/propertiesForm', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {
  
  
  return "checked=\"checked\"";
  }

function program3(depth0,data) {
  
  
  return "style=\"display:none\"";
  }

  buffer += "<div class=\"panel\">\n    <label for=\"\" class=\"has-icon\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Response identifier", options) : helperMissing.call(depth0, "__", "Response identifier", options)))
    + "</label>\n    <span class=\"icon-help tooltipstered\" data-tooltip=\"~ .tooltip-content:first\" data-tooltip-theme=\"info\"></span>\n    <div class=\"tooltip-content\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "The identifier of the choice. This identifier must not be used by any other response or item variable. An identifier is a string of characters that must start with a Letter or an underscore (\"_\") and contain only Letters, underscores, hyphens (\"-\"), period (\".\", a.k.a. full-stop), Digits, CombiningChars and Extenders.", options) : helperMissing.call(depth0, "__", "The identifier of the choice. This identifier must not be used by any other response or item variable. An identifier is a string of characters that must start with a Letter or an underscore (\"_\") and contain only Letters, underscores, hyphens (\"-\"), period (\".\", a.k.a. full-stop), Digits, CombiningChars and Extenders.", options)))
    + "</div>\n\n    <input type=\"text\"\n           name=\"identifier\"\n           value=\"";
  if (helper = helpers.identifier) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.identifier); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n           placeholder=\"e.g. RESPONSE\"\n           data-validate=\"$notEmpty; $qtiIdentifier; $availableIdentifier(serial=";
  if (helper = helpers.serial) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.serial); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ");\">\n</div>\n\n<hr />\n\n<h3>"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Options", options) : helperMissing.call(depth0, "__", "Options", options)))
    + "</h3>\n\n<div>\n    <label class=\"panel\">\n        <input name=\"authorizeWhiteSpace\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.authorizeWhiteSpace), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "authorize white space", options) : helperMissing.call(depth0, "__", "authorize white space", options)))
    + "\n    </label>\n    <label class=\"panel\">\n        <input name=\"useGapExpression\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useGapExpression), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "use expression with gaps", options) : helperMissing.call(depth0, "__", "use expression with gaps", options)))
    + "\n    </label>\n    <div class=\"panel mathgap-style-box\" ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.useGapExpression), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n        <label for=\"gapStyle\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Gap size", options) : helperMissing.call(depth0, "__", "Gap size", options)))
    + "</label>\n        <select name=\"gapStyle\" data-mathgap-style>\n            <option value=\"math-gap-small\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Small", options) : helperMissing.call(depth0, "__", "Small", options)))
    + "</option>\n            <option value=\"math-gap-medium\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Medium", options) : helperMissing.call(depth0, "__", "Medium", options)))
    + "</option>\n            <option value=\"math-gap-large\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Large", options) : helperMissing.call(depth0, "__", "Large", options)))
    + "</option>\n        </select>\n    </div>\n</div>\n\n<hr />\n\n<h3>"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Functions", options) : helperMissing.call(depth0, "__", "Functions", options)))
    + "</h3>\n\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_sqrt\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_sqrt), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"1em\" width=\"1em\" viewBox=\"0 0 400 400\" version=\"1.0\">\n            <path d=\"m193.39062 4.859375-50.8125 317.375-79.093743-160.71876-58.781256 29.46875l6.6250007 12.5 38.687495-17.75 96.875003 199.40625 58.6875-366.28124h144.71876v-14h-142.46876-10.21874-4.21876z\"></path>\n            <text class=\"\">âˆš</text>\n        </svg>\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "square root", options) : helperMissing.call(depth0, "__", "square root", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_frac\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_frac), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "fraction", options) : helperMissing.call(depth0, "__", "fraction", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_exp\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_exp), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        x&#8319; "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "exponent", options) : helperMissing.call(depth0, "__", "exponent", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_subscript\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_subscript), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        x&#8336; "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "subscript", options) : helperMissing.call(depth0, "__", "subscript", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_log\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_log), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "log", options) : helperMissing.call(depth0, "__", "log", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_ln\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_ln), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "ln", options) : helperMissing.call(depth0, "__", "ln", options)))
    + "\n    </label>\n</div>\n\n<hr />\n<h3>"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Symbols", options) : helperMissing.call(depth0, "__", "Symbols", options)))
    + "</h3>\n\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_e\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_e), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        e\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_infinity\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_infinity), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        &#8734;\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"roundbkts\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.roundbkts), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        ( ) "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "parentheses/round brackets", options) : helperMissing.call(depth0, "__", "parentheses/round brackets", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"curlybkts\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.curlybkts), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        { } "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "braces/curly brackets", options) : helperMissing.call(depth0, "__", "braces/curly brackets", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"squarebkts\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.squarebkts), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        [ ] "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "square brackets", options) : helperMissing.call(depth0, "__", "square brackets", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_integral\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_integral), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        &#x222b; "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Indefinite integral", options) : helperMissing.call(depth0, "__", "Indefinite integral", options)))
    + "\n    </label>\n</div>\n\n<hr />\n<h3>"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Geometry", options) : helperMissing.call(depth0, "__", "Geometry", options)))
    + "</h3>\n\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_angle\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_angle), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        &ang; "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "angle", options) : helperMissing.call(depth0, "__", "angle", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_integral\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_integral), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Indefinite integral", options) : helperMissing.call(depth0, "__", "Indefinite integral", options)))
    + "\n        </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_triangle\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_triangle), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        &#9651; "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "triangle", options) : helperMissing.call(depth0, "__", "triangle", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_similar\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_similar), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        &sim; "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "similar", options) : helperMissing.call(depth0, "__", "similar", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_paral\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_paral), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        &#8741; "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "is parallel with", options) : helperMissing.call(depth0, "__", "is parallel with", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_perp\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_perp), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        &#8869; "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "is perpendicular to", options) : helperMissing.call(depth0, "__", "is perpendicular to", options)))
    + "\n    </label>\n</div>\n\n<hr />\n<h3>"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Trigonometry", options) : helperMissing.call(depth0, "__", "Trigonometry", options)))
    + "</h3>\n\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_pi\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_pi), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        &pi;\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_cos\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_cos), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "cosinus", options) : helperMissing.call(depth0, "__", "cosinus", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_sin\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_sin), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "sinus", options) : helperMissing.call(depth0, "__", "sinus", options)))
    + "\n    </label>\n</div>\n\n<hr />\n<h3>"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Comparison", options) : helperMissing.call(depth0, "__", "Comparison", options)))
    + "</h3>\n\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_lower\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_lower), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        &lt; "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "lower than", options) : helperMissing.call(depth0, "__", "lower than", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_greater\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_greater), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        &gt; "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "greater than", options) : helperMissing.call(depth0, "__", "greater than", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_lte\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_lte), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "â‰¤", options) : helperMissing.call(depth0, "__", "â‰¤", options)))
    + " "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "lower than or equal", options) : helperMissing.call(depth0, "__", "lower than or equal", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_gte\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_gte), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "â‰¥", options) : helperMissing.call(depth0, "__", "â‰¥", options)))
    + " "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "greater than or equal", options) : helperMissing.call(depth0, "__", "greater than or equal", options)))
    + "\n    </label>\n</div>\n\n<hr />\n<h3>"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Operands", options) : helperMissing.call(depth0, "__", "Operands", options)))
    + "</h3>\n\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_equal\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_equal), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        = "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "equal", options) : helperMissing.call(depth0, "__", "equal", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_plus\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_plus), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        + "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "plus", options) : helperMissing.call(depth0, "__", "plus", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_minus\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_minus), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        â€“ "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "minus", options) : helperMissing.call(depth0, "__", "minus", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_times\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_times), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        &times; "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "times", options) : helperMissing.call(depth0, "__", "times", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_timesdot\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_timesdot), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        Â· "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "times dot", options) : helperMissing.call(depth0, "__", "times dot", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_divide\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_divide), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        &divide; "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "divide", options) : helperMissing.call(depth0, "__", "divide", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_plusminus\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_plusminus), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        &#177; "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Plus/minus", options) : helperMissing.call(depth0, "__", "Plus/minus", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_inmem\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_inmem), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "is a member of", options) : helperMissing.call(depth0, "__", "is a member of", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_ninmem\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_ninmem), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "is not a member of", options) : helperMissing.call(depth0, "__", "is not a member of", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_union\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_union), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "set union", options) : helperMissing.call(depth0, "__", "set union", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"tool_intersec\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.tool_intersec), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "set intersection", options) : helperMissing.call(depth0, "__", "set intersection", options)))
    + "\n    </label>\n</div>\n\n<hr />\n\n<h3 class=\"txt-error\"><strong><span class=\"icon-warning\"></span> "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Experimental only", options) : helperMissing.call(depth0, "__", "Experimental only", options)))
    + "</strong></h3>\n\n<div>\n    <label class=\"panel\">\n        <input name=\"allowNewLine\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.allowNewLine), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "allow line break", options) : helperMissing.call(depth0, "__", "allow line break", options)))
    + "\n    </label>\n</div>\n<div>\n    <label class=\"panel\">\n        <input name=\"enableAutoWrap\" type=\"checkbox\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enableAutoWrap), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "/>\n        <span class=\"icon-checkbox\"></span>\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "enable auto wrap", options) : helperMissing.call(depth0, "__", "enable auto wrap", options)))
    + "\n    </label>\n</div>";
  return buffer;
  });
});


define('tpl!mathEntryInteraction/creator/tpl/addGapBtn', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<div class=\"add-option\">\n    <span class=\"icon-add\"></span> "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Add gap", options) : helperMissing.call(depth0, "__", "Add gap", options)))
    + "\n</div>";
  return buffer;
  });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2022 (original work) Open Assessment Technologies SA;
 */
define('mathEntryInteraction/creator/helper/mathInPrompt',['core/moduleLoader'], function (moduleLoader) {
    'use strict';

    let MathJax;
    let loaded = false;

    /***
     * lazy-load MathJax dependency
     * @returns {Promise}
     */
    function load() {
        if (loaded) {
            return Promise.resolve();
        }
        return moduleLoader([], () => true)
            .add({ module: 'mathJax', category: 'mathEntryInteraction' })
            .load()
            .then(loadedModule => {
                loaded = true;
                MathJax = loadedModule && loadedModule.length ? loadedModule[0] : void 0;

                /**
                 * Do not wait between rendering each individual math element
                 * http://docs.mathjax.org/en/latest/api/hub.html
                 * @see https://github.com/oat-sa/tao-item-runner-qti-fe/blob/master/src/qtiCommonRenderer/renderers/Math.js
                 */
                if (MathJax && MathJax.Hub) {
                    MathJax.Hub.processSectionDelay = 0;
                }
            });
    }

    const mathInPrompt = {
        /**
         * On dom element containing `<math>...</math>` MathML markup,
         * run MathJax renderer ("typeset" it)
         * @param {Object} $element
         * @returns {Promise}
         */
        postRender: function postRender($element) {
            if ($element.find('math').length === 0) {
                return Promise.resolve();
            }
            return load().then(() => {
                if (MathJax && MathJax.Hub && typeof MathJax.Hub.Queue === 'function') {
                    /**
                     * MathJax needs to be exported globally to integrate with tools like TTS, it's weird...
                     * @see https://github.com/oat-sa/tao-item-runner-qti-fe/blob/master/src/qtiCommonRenderer/renderers/Math.js
                     */
                    if (!window.MathJax) {
                        window.MathJax = MathJax;
                    }
                    if ($element.length) {
                        MathJax.Hub.Queue(['Typeset', MathJax.Hub, $element[0]]);
                    }
                }
            });
        }
    };

    return mathInPrompt;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016-2017 (original work) Open Assessment Technologies SA;
 */

define('mathEntryInteraction/creator/widget/states/Question',[
    'jquery',
    'i18n',
    'taoQtiItem/qtiCreator/widgets/states/factory',
    'taoQtiItem/qtiCreator/widgets/interactions/states/Question',
    'taoQtiItem/qtiCreator/widgets/helpers/formElement',
    'taoQtiItem/qtiCreator/editor/simpleContentEditableElement',
    'taoQtiItem/qtiCreator/editor/containerEditor',
    'tpl!mathEntryInteraction/creator/tpl/propertiesForm',
    'tpl!mathEntryInteraction/creator/tpl/addGapBtn',
    'mathEntryInteraction/creator/helper/mathInPrompt'
], function($, __, stateFactory, Question, formElement, simpleEditor, containerEditor, formTpl, addGapBtnTpl, mathInPrompt){
    'use strict';

    var $addGapBtn = $(addGapBtnTpl());

    var MathEntryInteractionStateQuestion = stateFactory.extend(Question, function create(){
        var $container = this.widget.$container,
            $prompt = $container.find('.prompt'),
            interaction = this.widget.element;

        containerEditor.create($prompt, {
            change : function(text){
                interaction.data('prompt', text);
                interaction.updateMarkup();

                if (!$prompt.is('[data-html-editable-container="true"]')) {
                    mathInPrompt.postRender($prompt);
                }
            },
            markup : interaction.markup,
            markupSelector : '.prompt',
            related : interaction,
            areaBroker: this.widget.getAreaBroker()
        });

        if (toBoolean(interaction.prop('useGapExpression'), false)) {
            this.createAddGapBtn();
        }

        this.addMathFieldListener();

    }, function exit(){
        var $container = this.widget.$container,
            $prompt = $container.find('.prompt');

        simpleEditor.destroy($container);
        containerEditor.destroy($prompt);

        this.removeAddGapBtn();
    });

    function toBoolean(value, defaultValue) {
        if (typeof(value) === "undefined") {
            return defaultValue;
        } else {
            return (value === true || value === "true");
        }
    }
    /**
     * Callback for configuration change
     * @param {Object} interaction - the current interaction
     * @param {String} value - new value of the changed property
     * @param {String} name - changed property
     */
    function configChangeCallBack(interaction, value, name) {
        interaction.prop(name, value);
        interaction.triggerPci('configChange', [interaction.getProperties()]);
    }

    MathEntryInteractionStateQuestion.prototype.initForm = function initForm(){

        var self = this,
            _widget = this.widget,
            $form = _widget.$form,
            interaction = _widget.element,
            response = interaction.getResponseDeclaration(),
            $gapStyleBox,
            $gapStyleSelector;

        //render the form using the form template
        $form.html(formTpl({
            serial : response.serial,
            identifier : interaction.attr('responseIdentifier'),

            authorizeWhiteSpace: toBoolean(interaction.prop('authorizeWhiteSpace'), false),
            useGapExpression: toBoolean(interaction.prop('useGapExpression'), false),
            focusOnDenominator: toBoolean(interaction.prop('focusOnDenominator'), false),

            tool_frac:      toBoolean(interaction.prop('tool_frac'),    true),
            tool_sqrt:      toBoolean(interaction.prop('tool_sqrt'),    true),
            tool_exp:       toBoolean(interaction.prop('tool_exp'),     true),
            tool_log:       toBoolean(interaction.prop('tool_log'),     true),
            tool_ln:        toBoolean(interaction.prop('tool_ln'),      true),
            tool_e:         toBoolean(interaction.prop('tool_e'),       true),
            tool_infinity:  toBoolean(interaction.prop('tool_infinity'),true),
            squarebkts:     toBoolean(interaction.prop('tool_rbrack'),  true) && toBoolean(interaction.prop('tool_lbrack'), true),
            tool_pi:        toBoolean(interaction.prop('tool_pi'),      true),
            tool_cos:       toBoolean(interaction.prop('tool_cos'),     true),
            tool_sin:       toBoolean(interaction.prop('tool_sin'),     true),
            tool_lte:       toBoolean(interaction.prop('tool_lte'),     true),
            tool_gte:       toBoolean(interaction.prop('tool_gte'),     true),
            tool_times:     toBoolean(interaction.prop('tool_times'),   true),
            tool_divide:    toBoolean(interaction.prop('tool_divide'),  true),
            tool_plusminus: toBoolean(interaction.prop('tool_plusminus'),true),
            roundbkts:      toBoolean(interaction.prop('tool_rparen'),  true) && toBoolean(interaction.prop('tool_lparen'), true),
            curlybkts:      toBoolean(interaction.prop('tool_rbrace'),  true) && toBoolean(interaction.prop('tool_lbrace'), true),
            tool_angle:     toBoolean(interaction.prop('tool_angle'),   true),
            tool_minus:     toBoolean(interaction.prop('tool_minus'),   true),
            tool_plus:      toBoolean(interaction.prop('tool_plus'),    true),
            tool_equal:     toBoolean(interaction.prop('tool_equal'),   true),
            tool_lower:     toBoolean(interaction.prop('tool_lower'),   true),
            tool_greater:   toBoolean(interaction.prop('tool_greater'), true),
            tool_subscript: toBoolean(interaction.prop('tool_subscript'),true),
            tool_integral:  toBoolean(interaction.prop('tool_integral'),true),
            tool_timesdot:  toBoolean(interaction.prop('tool_timesdot'),true),
            tool_triangle:  toBoolean(interaction.prop('tool_triangle'),true),
            tool_similar:   toBoolean(interaction.prop('tool_similar'), true),
            tool_paral:     toBoolean(interaction.prop('tool_paral'),   true),
            tool_perp:      toBoolean(interaction.prop('tool_perp'),    true),
            tool_inmem:     toBoolean(interaction.prop('tool_inmem'),   true),
            tool_ninmem:    toBoolean(interaction.prop('tool_ninmem'),  true),
            tool_union:     toBoolean(interaction.prop('tool_union'),   true),
            tool_intersec:  toBoolean(interaction.prop('tool_intersec'),true),
            allowNewLine:   toBoolean(interaction.prop('allowNewLine'), false),
            enableAutoWrap: toBoolean(interaction.prop('enableAutoWrap'), false)
        }));

        //init form javascript
        formElement.initWidget($form);

            //init data change callbacks
            formElement.setChangeCallbacks($form, interaction, {
                identifier: function(i, value){
                response.id(value);
                interaction.attr('responseIdentifier', value);
            },
            useGapExpression: function gapChangeCallback(i, value) {
                if (toBoolean(value, false)) {
                    self.createAddGapBtn();
                    $gapStyleBox.show();
                } else {
                    i.prop('gapExpression', '');
                    self.removeAddGapBtn();
                    $gapStyleBox.hide();
                }

                response.attr('cardinality', 'single');
                configChangeCallBack(i, value, 'useGapExpression');
            },
            gapStyle: function gapStyleChangeCallback(i, newStyle) {

                i.prop('gapStyle', newStyle);

                configChangeCallBack(i, newStyle, 'gapStyle');
            },
            authorizeWhiteSpace: configChangeCallBack,
            focusOnDenominator: configChangeCallBack,

            tool_frac:      configChangeCallBack,
            tool_sqrt:      configChangeCallBack,
            tool_exp:       configChangeCallBack,
            tool_log:       configChangeCallBack,
            tool_ln:        configChangeCallBack,
            tool_e:         configChangeCallBack,
            tool_infinity:  configChangeCallBack,
            tool_pi:        configChangeCallBack,
            tool_cos:       configChangeCallBack,
            tool_sin:       configChangeCallBack,
            tool_lte:       configChangeCallBack,
            tool_gte:       configChangeCallBack,
            tool_times:     configChangeCallBack,
            tool_divide:    configChangeCallBack,
            tool_plusminus: configChangeCallBack,
            tool_angle:     configChangeCallBack,
            tool_minus:     configChangeCallBack,
            tool_plus:      configChangeCallBack,
            tool_equal:     configChangeCallBack,
            tool_lower:     configChangeCallBack,
            tool_greater:   configChangeCallBack,
            tool_subscript: configChangeCallBack,
            tool_integral:  configChangeCallBack,
            tool_timesdot:  configChangeCallBack,
            tool_triangle:  configChangeCallBack,
            tool_similar:   configChangeCallBack,
            tool_paral:     configChangeCallBack,
            tool_perp:      configChangeCallBack,
            tool_inmem:     configChangeCallBack,
            tool_ninmem:    configChangeCallBack,
            tool_union:     configChangeCallBack,
            tool_intersec:  configChangeCallBack,

            squarebkts: function squarebktsChangeCallBack(i, value) {
                i.prop('tool_lbrack', value);
                i.prop('tool_rbrack', value);
                i.triggerPci('configChange', [i.getProperties()]);
            },
            roundbkts: function roundbktsChangeCallBack(i, value) {
                i.prop('tool_lparen', value);
                i.prop('tool_rparen', value);
                i.triggerPci('configChange', [i.getProperties()]);
            },
            curlybkts: function curlybktsChangeCallBack(i, value) {
                i.prop('tool_lbrace', value);
                i.prop('tool_rbrace', value);
                i.triggerPci('configChange', [i.getProperties()]);
            },

            allowNewLine: configChangeCallBack,
            enableAutoWrap: configChangeCallBack
        });


        $gapStyleBox = $form.find('.mathgap-style-box');
        $gapStyleSelector = $gapStyleBox.find('[data-mathgap-style]');

        $gapStyleSelector.select2({
            width: '100%',
            minimumResultsForSearch: Infinity
        })
        .val(interaction.prop('gapStyle'))
        .trigger('change');
    };

    /**
     * Change callback for editable math field
     */

    MathEntryInteractionStateQuestion.prototype.addMathFieldListener = function addMathFieldListener() {
        var _widget = this.widget,
            interaction = _widget.element;

        interaction.onPci('responseChange', function(latex) {
            if (toBoolean(interaction.prop('useGapExpression'), false)) {
                interaction.prop('gapExpression', latex);
            } else {
                interaction.prop('gapExpression', '');
            }
        });
    };

    /**
     * Display the "Add Gap" button
     */
    MathEntryInteractionStateQuestion.prototype.createAddGapBtn = function createAddGapBtn() {
        var _widget = this.widget,
            $container = _widget.$container,
            $toolbar = $container.find('.toolbar'),
            interaction =_widget.element;

        if ($toolbar.length) {
            $toolbar.after($addGapBtn);
            $addGapBtn.on('click', function() {
                interaction.getResponseDeclaration().removeMapEntries();
                interaction.triggerPci('addGap');
            });
        }
    };

    /**
     * Remove the "Add Gap" button from the DOM
     */
    MathEntryInteractionStateQuestion.prototype.removeAddGapBtn = function removeAddGapBtn() {
        $addGapBtn.off('click');
        $addGapBtn.remove();
    };

    return MathEntryInteractionStateQuestion;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2021 (original work) Open Assessment Technologies SA;
 */
define('mathEntryInteraction/creator/widget/states/Correct',[
    'taoQtiItem/qtiCreator/widgets/states/factory',
    'taoQtiItem/qtiCreator/widgets/states/Correct'
], function (stateFactory, Correct) {
    'use strict';

    var InteractionStateCorrect = stateFactory.create(
        Correct,
        function init() {
            this.widget.element.getResponseDeclaration().setTemplate('MAP_RESPONSE');
            this.widget.changeState('map');
        },
        function exit() {
        }
    );

    return InteractionStateCorrect;
});


define('tpl!mathEntryInteraction/creator/tpl/answerForm', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n                <div class=\"correct-answer-entry\" data-index=\""
    + escapeExpression(((stack1 = (data == null || data === false ? data : data.index)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\">\n                    <p>"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Correct answer option", options) : helperMissing.call(depth0, "__", "Correct answer option", options)))
    + " "
    + escapeExpression((helper = helpers.increaseIndex || (depth0 && depth0.increaseIndex),options={hash:{},data:data},helper ? helper.call(depth0, (data == null || data === false ? data : data.index), options) : helperMissing.call(depth0, "increaseIndex", (data == null || data === false ? data : data.index), options)))
    + "</p>\n                    <a href=\"#\" class=\"answer-edit\">\n                        <span class=\"icon-edit\"></span>\n                        <span>"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "edit the answer", options) : helperMissing.call(depth0, "__", "edit the answer", options)))
    + "</span>\n                    </a>\n\n                    <br>\n\n                    <a href=\"#\" class=\"answer-delete\">\n                        <span class=\"icon-bin\"></span>\n                        <span>"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "delete the answer", options) : helperMissing.call(depth0, "__", "delete the answer", options)))
    + "</span>\n                    </a>\n                </div>\n                <br>\n                ";
  return buffer;
  }

  buffer += "<div class=\"panel mathEntryInteraction\">\n    <hr>\n    <h3>"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Define correct responses", options) : helperMissing.call(depth0, "__", "Define correct responses", options)))
    + ":</h3>\n    <div class=\"answer-entries-config\" data-config-for-hot-uid=\""
    + escapeExpression(((stack1 = (data == null || data === false ? data : data.key)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\">\n        <div class=\"panel\">\n            <div class=\"entry-config\">\n                ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.correctAnswerEntries), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n            </div>\n        </div>\n\n    </div>\n\n</div>";
  return buffer;
  });
});


define('tpl!mathEntryInteraction/creator/tpl/addAnswerOption', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<button class=\"add-answer-option btn-info\">\n    <i class=\"adder\"> </i> "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Add answer option", options) : helperMissing.call(depth0, "__", "Add answer option", options)))
    + "\n</button>";
  return buffer;
  });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2021 (original work) Open Assessment Technologies SA;
 */
define('mathEntryInteraction/creator/widget/states/Map',[
    'handlebars',
    'i18n',
    'lodash',
    'jquery',
    'taoQtiItem/qtiCreator/widgets/states/factory',
    'taoQtiItem/qtiCreator/widgets/states/Map',
    'taoQtiItem/qtiCreator/widgets/helpers/formElement',
    'tpl!mathEntryInteraction/creator/tpl/answerForm',
    'tpl!mathEntryInteraction/creator/tpl/addAnswerOption',
], function (
    hb,
    __,
    _,
    $,
    stateFactory,
    Map,
    formElement,
    answerFormTpl,
    addAnswerOptionBtn
) {
    'use strict';
    var CORRECT_ANSWER_VALUE = 1;
    hb.registerHelper('increaseIndex', function (value, options) {
        return parseInt(value) + 1;
    });

    var MathEntryInteractionStateResponse = stateFactory.create(
        Map,
        function init() {
            this.initGlobalVariables();
            this.initForm();
        },
        function exit() {
            this.emptyGapFields();
            this.toggleResponseMode(false);
            this.saveAnswers();
            this.removeResponseChangeEventListener();
            this.removeEditDeleteListeners();
            this.removeAddButtonListener();
            this.destroyForm();
        }
    );


    MathEntryInteractionStateResponse.prototype.initGlobalVariables = function initGlobalVariables() {
        var self = this,
            interaction = self.widget.element;
        self.activeEditId = null;
        self.correctResponses = [];

        if (this.inGapMode(self) === true) {
            interaction = self.widget.element;
            self.gapTemplate = interaction.prop('gapExpression');
        }
    }

    MathEntryInteractionStateResponse.prototype.initForm = function initForm() {
        var self = this,
            interaction = self.widget.element,
            $responseForm = self.widget.$responseForm;

        this.initResponseChangeEventListener();
        self.correctResponses = this.getExistingCorrectAnswerOptions();
        $responseForm.html(addAnswerOptionBtn());
        this.initAddAnswerButton();
        this.renderForm(self.correctResponses);
    }

    MathEntryInteractionStateResponse.prototype.initAddAnswerButton = function initAddAnswerButton() {
        var self = this,
            interaction = self.widget.element,
            $responseForm = self.widget.$responseForm,
            $addAnswerBtn = $responseForm.find($('.add-answer-option'));

        $addAnswerBtn.on('click', function () {
            var newCorrectAnswer;

            if (self.inGapMode() === true) {
                self.emptyGapFields();
                var gapExpression = interaction.prop('gapExpression');
                var gapCount = (gapExpression.match(/\\taoGap/g) || []).length;
                if (gapCount > 0) {
                    newCorrectAnswer = [];
                    for (var i = 0; i < gapCount; i++) {
                        newCorrectAnswer.push(' ');
                    }

                    newCorrectAnswer = newCorrectAnswer.join(',');
                } else {
                    newCorrectAnswer = '';
                }
            } else {
                newCorrectAnswer = '';
                self.toggleResponseMode(false);
            }

            self.correctResponses.push(newCorrectAnswer);
            self.renderForm(self.correctResponses);
        });
    }

    MathEntryInteractionStateResponse.prototype.getExistingCorrectAnswerOptions = function getExistingCorrectAnswerOptions() {
        var self = this,
            interaction = self.widget.element;

        var mapEntries = interaction.getResponseDeclaration().getMapEntries();
        return _.keys(mapEntries) || [];
    }

    MathEntryInteractionStateResponse.prototype.initResponseChangeEventListener = function initResponseChangeEventListener() {
        var self = this,
            interaction = self.widget.element;

        interaction.onPci('responseChange', function (latex) {
            if (self.inGapMode(self) === false && self.activeEditId !== null) {
                self.correctResponses[self.activeEditId] = latex;
            } else if (self.inGapMode(self) === true && self.activeEditId !== null) {
                var response = interaction.getResponse();
                if (response !== null) {
                    self.correctResponses[self.activeEditId] = response.base.string;
                }
            }
        });
    }

    MathEntryInteractionStateResponse.prototype.removeResponseChangeEventListener = function removeResponseChangeEventListener() {
        var self = this,
            interaction = self.widget.element;

        interaction.offPci('responseChange');
    }

    MathEntryInteractionStateResponse.prototype.initEditingOptions = function initEditingOptions() {
        var self = this,
            interaction = self.widget.element,
            $responseForm = self.widget.$responseForm,
            $entryConfig = $responseForm.find('.entry-config'),
            $editButtons = $entryConfig.find('.answer-edit');

        $editButtons.click(function (e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            self.toggleResponseMode(true);
            var selectedEditId = parseInt($(e.target).closest('div').attr('data-index'));

            if (self.activeEditId !== selectedEditId) {

                if (self.inGapMode() === true) {
                    self.activeEditId = selectedEditId;
                    var response = self.getGapResponseObject(self.correctResponses[self.activeEditId]);
                    interaction.triggerPci('latexGapInput', [response]);
                } else {
                    self.activeEditId = selectedEditId;
                    interaction.triggerPci('latexInput', [self.correctResponses[self.activeEditId]]);
                }
            } else {
                self.emptyGapFields();
            }
        });
    }

    // forming gap response object to be further processed by the latexGapInput event
    MathEntryInteractionStateResponse.prototype.getGapResponseObject = function getGapResponseObject(response) {
        return {
            base: {
                string: response.split(',')
            }
        }
    }

    // removing all saved map entries
    MathEntryInteractionStateResponse.prototype.clearMapEntries = function clearMapEntries() {
        var self = this,
            interaction = self.widget.element,
            response = interaction.getResponseDeclaration(),
            mapEntries = response.getMapEntries();

        _.keys(mapEntries).forEach(function (mapKey) {
            response.removeMapEntry(mapKey, true);
        });
    }

    MathEntryInteractionStateResponse.prototype.initDeletingOptions = function initDeletingOptions() {
        var self = this,
            interaction = self.widget.element,
            $responseForm = self.widget.$responseForm,
            $entryConfig = $responseForm.find('.entry-config'),
            $deleteButtons = $entryConfig.find('.answer-delete');

        $deleteButtons.click(function (e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            var id = parseInt($(e.target).closest('div').attr('data-index'));

            if (self.inGapMode() === true) {
                self.activeEditId = id;
                self.emptyGapFields();
            } else {
                self.activeEditId = null;
                self.toggleResponseMode(false);
            }

            self.correctResponses.splice(id, 1);
            self.renderForm(self.correctResponses);
        });
    }

    MathEntryInteractionStateResponse.prototype.renderForm = function renderForm(correctAnswerOptions) {
        var self = this,
            $responseForm = self.widget.$responseForm;

        this.removeEditDeleteListeners();
        $responseForm.find('.mathEntryInteraction').remove();
        $responseForm.append(answerFormTpl({correctAnswerEntries: correctAnswerOptions}));
        this.initDeletingOptions();
        this.initEditingOptions();
    }

    /**
     *   remove all event listeners to avoid any potential memory leaks
     */
    MathEntryInteractionStateResponse.prototype.removeEditDeleteListeners = function removeEditDeleteListeners() {
        var self = this,
            $entryConfig = self.widget.$responseForm.find('.entry-config');

        $entryConfig.find('.answer-edit').off('click');
        $entryConfig.find('.answer-delete').off('click');
    }

    MathEntryInteractionStateResponse.prototype.removeAddButtonListener = function removeAddButtonListener() {
        var self = this,
            $responseForm = self.widget.$responseForm;

        $responseForm.find($('.add-answer-option')).off('click');
    }

    MathEntryInteractionStateResponse.prototype.destroyForm = function destroyForm() {
        var self = this,
            $responseForm = self.widget.$responseForm;

        $responseForm.find('.mathEntryInteraction').remove();
    }

    MathEntryInteractionStateResponse.prototype.saveAnswers = function saveAnswers() {
        var self = this,
            interaction = self.widget.element,
            responseDeclaration = interaction.getResponseDeclaration();

        this.clearMapEntries();

        if (this.inGapMode() === true) {
            self.correctResponses = self.correctResponses.filter(function (response) {
                return response.split(',').indexOf('') === -1;
            });
        }

        self.correctResponses.forEach(function (response) {
            responseDeclaration.setMapEntry(response, CORRECT_ANSWER_VALUE, false);
        });
    }

    /**
     *   if in gap mode: will empty all the gap fields
     */
    MathEntryInteractionStateResponse.prototype.emptyGapFields = function emptyGapFields() {
        var self = this,
            interaction = self.widget.element;

        if (this.inGapMode() === true) {
            self.activeEditId = null;

            interaction.prop('gapExpression', self.gapTemplate);
            this.toggleResponseMode(false);
        }
    }

    MathEntryInteractionStateResponse.prototype.toggleResponseMode = function toggleResponseMode(value) {
        var self = this,
            interaction = self.widget.element;

        if (interaction.prop('inResponseState') !== value) {
            interaction.prop('inResponseState', value);
            interaction.triggerPci('configChange', [interaction.getProperties()]);
        }
    }

    MathEntryInteractionStateResponse.prototype.inGapMode = function inGapMode() {
        var interaction = this.widget.element;
        var useGapExpression = interaction.prop('useGapExpression');
        return useGapExpression && useGapExpression !== 'false' || false;
    }

    return MathEntryInteractionStateResponse;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA;
 */

define('mathEntryInteraction/creator/widget/states/states',[
    'taoQtiItem/qtiCreator/widgets/states/factory',
    'taoQtiItem/qtiCreator/widgets/interactions/customInteraction/states/states',
    'mathEntryInteraction/creator/widget/states/Question',
    'mathEntryInteraction/creator/widget/states/Correct',
    'mathEntryInteraction/creator/widget/states/Map'
], function(factory, states){
    'use strict';

    return factory.createBundle(states, arguments);
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA;
 */

define('mathEntryInteraction/creator/widget/Widget',[
    'taoQtiItem/qtiCreator/widgets/interactions/customInteraction/Widget',
    'mathEntryInteraction/creator/widget/states/states'
], function(Widget, states){
    'use strict';

    var MathEntryInteractionWidget = Widget.clone();

    MathEntryInteractionWidget.initCreator = function initCreator() {
        var $interaction;

        this.registerStates(states);

        Widget.initCreator.call(this);

        $interaction = this.$container.find('.mathEntryInteraction');
        if ($interaction.length) {
            $interaction.addClass('tao-qti-creator-context');
        }
    };

    return MathEntryInteractionWidget;
});

define('tpl!mathEntryInteraction/creator/tpl/markup', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function";


  buffer += "<div class=\"mathEntryInteraction\">\n    <div class=\"prompt\">";
  if (helper = helpers.prompt) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.prompt); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n    <div class=\"math-entry\">\n        <div class=\"toolbar\"></div>\n        <div>\n            <span class=\"math-entry-input\"></span>\n        </div>\n    </div>\n</div>";
  return buffer;
  });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016-2021 (original work) Open Assessment Technologies SA;
 *
 * @author Christophe NoÃ«l <christophe@taotesting.com>
 *
 */

define('mathEntryInteraction/imsPciCreator',[
    'lodash',
    'mathEntryInteraction/creator/widget/Widget',
    'tpl!mathEntryInteraction/creator/tpl/markup'
], function (_, Widget, markupTpl) {
    'use strict';

    var _typeIdentifier = 'mathEntryInteraction';

    var mathEntryInteractionCreator = {
        /**
         * (required) Get the typeIdentifier of the custom interaction
         *
         * @returns {String}
         */
        getTypeIdentifier: function getTypeIdentifier() {
            return _typeIdentifier;
        },
        /**
         * (required) Get the widget prototype
         * Used in the renderer
         *
         * @returns {Object} Widget
         */
        getWidget: function getWidget() {
            return Widget;
        },
        /**
         * (optional) Get the default properties values of the pci.
         * Used on new pci instance creation
         *
         * @returns {Object}
         */
        getDefaultProperties: function getDefaultProperties() {
            return {
                authorizeWhiteSpace: 'false',
                useGapExpression: 'false',
                inResponseState: 'false',
                gapExpression: '',
                gapStyle: '',
                focusOnDenominator: false,

                tool_frac: 'true',
                tool_sqrt: 'true',
                tool_exp: 'true',
                tool_log: 'true',
                tool_ln: 'true',
                tool_e: 'true',
                tool_infinity: 'true',
                tool_lbrack: 'true',
                tool_rbrack: 'true',
                tool_pi: 'true',
                tool_cos: 'true',
                tool_sin: 'true',
                tool_lte: 'true',
                tool_gte: 'true',
                tool_times: 'true',
                tool_divide: 'true',
                tool_plusminus: 'true',
                tool_angle: 'true',
                tool_minus: 'true',
                tool_plus: 'true',
                tool_equal: 'true',
                tool_lower: 'true',
                tool_greater: 'true',
                tool_subscript: 'true',
                tool_lbrace: 'true',
                tool_rbrace: 'true',
                tool_lparen: 'true',
                tool_rparen: 'true',
                tool_integral: 'true',
                tool_timesdot: 'true',
                tool_triangle: 'true',
                tool_similar: 'true',
                tool_paral: 'true',
                tool_perp: 'true',
                tool_inmem: 'true',
                tool_ninmem: 'true',
                tool_union: 'true',
                tool_intersec: 'true',
                allowNewLine: 'false',
                enableAutoWrap: 'false'
            };
        },
        /**
         * (optional) Callback to execute on the
         * Used on new pci instance creation
         *
         * @returns {Object}
         */
        afterCreate: function afterCreate(pci) {
            //do some stuff
        },
        /**
         * (required) Gives the qti pci xml template
         *
         * @returns {function} handlebar template
         */
        getMarkupTemplate: function getMarkupTemplate() {
            return markupTpl;
        },
        /**
         * (optional) Allows passing additional data to xml template
         *
         * @returns {function} handlebar template
         */
        getMarkupData: function getMarkupData(pci, defaultData) {
            defaultData.prompt = pci.data('prompt');
            return defaultData;
        }
    };

    //since we assume we are in a tao context, there is no use to expose the a global object for lib registration
    //all libs should be declared here
    return mathEntryInteractionCreator;
});

define(['mathEntryInteraction/imsPciCreator'],function(IMSPCI){return IMSPCI});

//# sourceMappingURL=imsPciCreator.min.js.map